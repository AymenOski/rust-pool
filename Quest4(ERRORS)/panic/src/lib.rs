use std::fs::File;

pub fn open_file(s: &str) -> File {
    File::open(s).unwrap()
}

/*
    * Q & A :
    * Q1 : What is a file descriptor?   
    - A1 : A file descriptor is a unique, non-negative integer used by Unix and Unix-like operating systems (such as Linux and macOS) to identify and reference an open file or other Input/Output (I/O) resource. When a process opens a file, the operating system assigns it a file descriptor, which can then be used to perform various operations on the file, such as reading, writing, or closing it. File descriptors are typically managed by the operating system and are used to keep track of open files and their associated resources. In Rust, when you use functions like `File::open`, they return a `Result` type that contains either a `File` object (on success) or an error (on failure). The `unwrap` method is used to extract the `File` object from the `Result`, but if the operation fails (e.g., if the file does not exist), it will panic and terminate the program with an error message.
    * Q2 : What is this file object?
    - A2 : In Rust, a file object is an instance of the `File` struct from the `std::fs` module. It represents an open file and provides methods for reading from, writing to, and managing the file. The `File` struct is a wrapper around a file descriptor, which is a low-level representation of an open file in the operating system. When you create a file object using `File::open`, it attempts to open the specified file and returns a `Result` type that contains either the `File` object (on success) or an error (on failure). Once you have a `File` object, you can use its methods to perform various operations on the file, such as reading data, writing data, or closing the file when you're done. The `File` struct also implements the `Read` and `Write` traits, allowing you to use it with Rust's I/O system for more complex operations.
    * Q3 : What do we mean by this : "The `File` struct also implements the `Read` and `Write` traits, allowing you to use it with Rust's I/O system for more complex operations"?
    - A3 : In Rust, X implements the Y trait means i can use the methods defined in the Y trait on instances of X. The `Read` and `Write` traits are part of Rust's standard library and define a set of methods for reading from and writing to I/O resources, such as files, network streams, or in-memory buffers. When we say that the `File` struct implements the `Read` and `Write` traits, it means that you can use the methods defined in those traits (like `read`, `write`, `read_to_string`, etc.) directly on instances of `File`. This allows you to perform more complex operations on files, such as reading data into a buffer, writing data from a buffer, or even using higher-level abstractions like `BufReader` and `BufWriter` for efficient I/O operations. By implementing these traits, the `File` struct can seamlessly integrate with Rust's I/O system, making it easier to work with files in a flexible and efficient manner.
`*/
